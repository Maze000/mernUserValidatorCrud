
esquema inicial de la base de usuarios

//const userSchema = new mongoose.Schema({
   // username: { type: String, required: true, unique: true },
    //email: { type: String, required: true, unique: true },
    // Otros campos necesarios para tu aplicación...
//});

//const User = mongoose.model('User', userSchema);

----------0--------------
cosola comentado


import React, { useState, useEffect } from 'react';
//import jwt_decode from 'jwt-decode'; // Asegúrate de haber instalado jwt-decode
import axios from 'axios'; // Asegúrate de haber instalado axios

import { jwtDecode } from 'jwt-decode';
 // Importa jwt-decode
const Consola = () => {
    const [users, setUsers] = useState([]); // Para almacenar la lista de usuarios
    const [receiverId, setReceiverId] = useState(''); // Para almacenar la ID del receptor seleccionado
    const [messageContent, setMessageContent] = useState(''); // Para almacenar el contenido del mensaje

    // Usando el token para decodificar y obtener el userId
    const token = localStorage.getItem('token');
    let userId = null;

    if(token){
    const decoded = jwtDecode(token); // Usando jwt-decode u otra biblioteca similar
    userId = decoded.userId;
    }
    // Cargar la lista de usuarios al iniciar el componente
    //useEffect(() => {
      //  fetchUsers();
    //}, []);

    // Función para cargar la lista de usuarios
    //const fetchUsers = () => {
      //  fetch('/users')
        //    .then(response => {
          //      if (!response.ok) {
            //        throw new Error('Network response was not ok');
              //  }
                //return response.json();
           // })
            //.then(data => {
              //  setUsers(data);
            //})
           // .catch(error => console.error('Error al cargar los usuarios:', error));
   // };
    

    // Función para enviar un mensaje
    //const sendMessage = () => {
      //if (!receiverId || !messageContent.trim()) {
        //    alert('Por favor, selecciona un usuario y escribe un mensaje.');
          //  return;
       // }

       // fetch('/send-message', {
         //   method: 'POST',
           // headers: {
             //   'Content-Type': 'application/json',
            //},
           // body: JSON.stringify({ senderId: userId, receiverId, content: messageContent }),
        //})
          //  .then(response => {
            //    if (!response.ok) {
              //      throw new Error('Error en la solicitud');
                //}
               // return response.json();
            //})
           // .then(data => {
             //   console.log('Mensaje enviado', data);
               // setMessageContent(''); // Limpiar el campo del mensaje después de enviar
              //  alert('Mensaje enviado exitosamente');
            //})
            //.catch(error => {
              //  console.error('Error al enviar el mensaje:', error);
                //alert('Error al enviar el mensaje');
           // });
   // };

    // Función para manejar la selección de un usuario
    //const handleSelectUser = (userId) => {
      //  setReceiverId(userId);
    //};

    // Función para cargar los mensajes recibidos
    //const fetchMessages = () => {
      //  fetch(`/received-messages/${userId}`, {
        //    method: 'GET',
          //  headers: {
            //    'Authorization': `Bearer ${token}` // Incluye el token en el header de autorización
           // }
       // })
         //   .then(response => response.json())
           // .then(data => {
             //   console.log('Mensajes recibidos:', data); // Aquí manejas los mensajes recibidos
           // })
           // .catch(error => console.error('Error al cargar mensajes:', error));
    //};

    return (
        <div>
            <div>
                {users.map((user) => (
                    <div key={user._id} onClick={() => handleSelectUser(user._id)}>
                        {user.email}
                    </div>
                ))}
            </div>
            <textarea
                value={messageContent}
                onChange={(e) => setMessageContent(e.target.value)}
                placeholder="Escribe tu mensaje aquí"
            />
            <button onClick={sendMessage}>
                {receiverId ? 'Enviar Mensaje' : 'No hay Usuario Seleccionado'}
            </button>
            <button onClick={fetchMessages}>Mensajes</button>
        </div>
    );
};

export default Consola;

-------------0-------------
consola usando correcto antes de agregar mensajes configurados

 import React, { useState, useEffect } from 'react';
//import jwt_decode from 'jwt-decode'; // Asegúrate de haber instalado jwt-decode
//import { Link } from 'react-router-dom';
import Logout from './Logout';
import { jwtDecode } from 'jwt-decode';
 // Importa jwt-decode
const Consola = () => {
    const [users, setUsers] = useState([]); // Para almacenar la lista de usuarios
    const [receiverId, setReceiverId] = useState(''); // Para almacenar la ID del receptor seleccionado
    const [messageContent, setMessageContent] = useState(''); // Para almacenar el contenido del mensaje
    const [mensajes, setDataContet] = useState([]);

    // Usando el token para decodificar y obtener el userId
    const token = localStorage.getItem('token');
    let userId = null;

    if(token){
    const decoded = jwtDecode(token); // Usando jwt-decode u otra biblioteca similar
    userId = decoded.userId;
    console.log('este es el userId del token',userId);
    }
    // Cargar la lista de usuarios al iniciar el componente
    useEffect(() => {
        fetchUsers();
    }, []);

    // Función para cargar la lista de usuarios
    const fetchUsers = () => {
        fetch('/users')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('esto es lo que devuelve el server',data);
                setUsers(data);
            })
            .catch(error => console.error('Error al cargar los usuarios:', error));
    };
    

    // Función para enviar un mensaje
    const sendMessage = () => {
        if (!receiverId || !messageContent.trim()) {
            alert('Por favor, selecciona un usuario y escribe un mensaje.');
            return;
        }

        fetch('/send-message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ senderId: userId, receiverId: receiverId, content: messageContent }),
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Error en la solicitud');
                }
                return response.json();
            })
            .then(data => {
                console.log('Mensaje enviado', data);
                setMessageContent(''); // Limpiar el campo del mensaje después de enviar
                alert('Mensaje enviado exitosamente');
            })
            .catch(error => {
                console.error('Error al enviar el mensaje:', error);
                alert('Error al enviar el mensaje');
            });
    };

    // Función para manejar la selección de un usuario
    const handleSelectUser = (userId) => {
        setReceiverId(userId);
    };

    // Función para cargar los mensajes recibidos
    const fetchMessages = () => {
        fetch(`/received-messages/${userId}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}` // Incluye el token en el header de autorización
            }
        })
            .then(response => response.json())
            .then(data => {
                console.log('Mensajes recibidos:', data); // Aquí manejas los mensajes recibidos

                setDataContet(data);
            })
            .catch(error => console.error('Error al cargar mensajes:', error));
    };
                                                           
    return (
        <div>
            <div>
                {users.map((user) => (
                     <div key={user._id}><button  onClick={() => handleSelectUser(user._id)}>
                        {user._id}
                        {user.local.email}
                        </button></div>
                ))}
            </div>
            <textarea                                                      
                value={messageContent}
                onChange={(e) => setMessageContent(e.target.value)}
                placeholder="Escribe tu mensaje aquí"
            />
            <button onClick={sendMessage}>
                {receiverId ? 'Enviar Mensaje' : 'No hay Usuario Seleccionado'}
            </button>
            <button onClick={fetchMessages}>Mensajes</button>
            <div>{mensajes.map((message,index) => (
  <div key={index}>
    <p>De: {message.sender.local.email}</p>
    <p>Mensaje: {message.content}</p>
    <p>Enviado: {new Date(message.timestamp).toLocaleString()}</p>
  </div>
))}</div>

<Logout/>
        </div>
    );
};

export default Consola;

-----------0------------

condigo de passport con callback antes de promesas

const LocalStrategy = require('passport-local').Strategy;


const {User} = require('./user');

module.exports = function (passport) {

  passport.serializeUser(function (user, done) {
    done(null, user.id);
  });


  passport.deserializeUser(function (id, done) {
    User.findById(id, function (err, user) {
      done(err, user);
    });
  });





  passport.use('local-signup', new LocalStrategy({

    usernameField: 'email',
    passwordField: 'password',
    passReqToCallback: true
  },
    function (req, email, password, done) {

      User.findOne({ 'local.email': email }, function (err, user) {
        if (err) {
          return done(err);
        }
        if (user) {

          return done(null, false, req.flash('signupMessage', 'the email is already taken'));
        } else {
          var newUser = new User();

          newUser.local.email = email;
         // newUser.email = email;//nuevo
          newUser.local.password = newUser.generateHash(password);
          newUser.save(function (err) {
            if (err) { throw err; }
            console.log(email);
            return done(null, newUser);
          });
        }
      });
    }));


  passport.use('local-login', new LocalStrategy({
    usernameField: 'email',
    passwordField: 'password',
    passReqToCallback: true
  },
    function (req, email, password, done) {
      User.findOne({ 'local.email': email }, function (err, user) {

        if (err) { return done(err); }
        if (!user) {
          return done(null, false, req.flash('loginMessage', 'No User found'))
        }
        if (!user.validPassword(password)) {
          return done(null, false, req.flash('loginMessage', 'Wrong. password'));
        }
        return done(null, user);
      });
    }));
}

-------0------------
passport signup antes de modificacion 

passport.use('local-signup', new LocalStrategy({
    usernameField: 'email',
    passwordField: 'password',
    passReqToCallback: true
  },
  function(req, email, password, done) {
    User.findOne({ 'local.email': email }).then(user => {
      if (user) {
        return done(null, false, req.flash('signupMessage', 'That email is already taken.'));
      } else {
        var newUser = new User();
        newUser.local.email = email;
        newUser.local.password = newUser.generateHash(password);

        return newUser.save();
      }
    })
    .then(newUser => done(null, newUser))
    .catch(err => done(err));
  }
));

-----------0----------

import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import useToken from './AuthenticateToken';

const PrivateRoute = ({ children }) => {
  const navigate = useNavigate();
  const { token, isTokenExpired } = useToken();

  useEffect(() => {
    if (token && !isTokenExpired) {
      // Si el token no existe o ha expirado, redirigir a /login
      navigate('/login');
    }
  }, [token, isTokenExpired, navigate]);  // Ejecutar cuando el token o su estado de expiración cambien

  // Si el usuario está autenticado, mostrar los children (contenido protegido)
  return token && !isTokenExpired ? children : null;
};

export default PrivateRoute;

----------------0-------

import React from 'react';
import { Navigate } from 'react-router-dom';
import { useNavigate } from 'react-router-dom';
import useToken from './AuthenticateToken';

const PrivateRoute = ({ children }) => {
  const navigate = useNavigate();
  const { token, isTokenExpired } = useToken();
  const isAuthenticated = token && !isTokenExpired;
  return isAuthenticated ? children : navigate('/login');;
};

export default PrivateRoute;


-----------0------------
 funcionando perfecto con isTokenExpired

 import { useState, useEffect } from 'react';

function parseJwt(token) {
    try {
        if (token) { 
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const payload = JSON.parse(window.atob(base64));
            return payload;
        }
        return null;
    } catch (error) {
        console.error("Error decoding token:", error);
        return null;
    }
}

function useToken() {
    const [token, setToken] = useState(localStorage.getItem('token'));

    const isTokenExpired = (token) => {
        if (!token) return true;  
        const payload = parseJwt(token);
        if (!payload) return true; 
        const currentTime = Date.now() / 1000;
        return currentTime > payload.exp; 
    };

    useEffect(() => {
        const handleStorageChange = () => {
            setToken(localStorage.getItem('token')); 
        };

        window.addEventListener('storage', handleStorageChange);
        return () => {
            window.removeEventListener('storage', handleStorageChange);
        };
    }, []);

    
    useEffect(() => {
        const intervalId = setInterval(() => {
            if (token) {
                const payload = parseJwt(token);
                if (payload) {
                    const currentTime = Date.now() / 1000;
                    if (currentTime > payload.exp) {
                        localStorage.removeItem('token');
                        setToken(null); 
                    }
                }
            }
        }, 1000); 

        
        return () => clearInterval(intervalId);
    }, [token]);

    return { token, isTokenExpired: isTokenExpired(token) };
}

export default useToken;


----------0-----------

supertest inicial

const request = require('supertest');
const mongoose = require('mongoose');
const Task= require('./server').Task;  
const app = require('./server').app; 

beforeAll(() => {
    const url = `mongodb://127.0.0.1/mern-test-6`;
    return new Promise((resolve, reject) => {
      mongoose.connect(url)
        .then(() => resolve())
        .catch((err) => reject(err));
    });
  });
  
  afterAll(() => {
    return new Promise((resolve, reject) => {
      mongoose.connection.close()
        .then(() => resolve())
        .catch((err) => reject(err));
    });
  });

  ---------0-----------

  antes de jest 

  passport.use('local-signup', new LocalStrategy({
    usernameField: 'email',
    passwordField: 'password',
    passReqToCallback: true
  },
    function (req, email, password, done) {

      User.findOne({ 'local.email': email })
        .then(user => {
          if (user) {

            return done(null, false, req.flash('signupMessage', 'That email is already taken.'));
          } else {

            var newUser = new User();
            newUser.local.email = email;
            newUser.local.password = newUser.generateHash(password);


            return newUser.save();
          }
        })
        .then(newUser => {

          if (newUser) {
            return done(null, newUser);
          }
        })
        .catch(err => {

          return done(err);
        });
    }
  ));

  -------------0-----------
prueba 1 ci 

name: CI/CD Pipeline

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  run-tests-and-build:
    runs-on: ubuntu-latest

    services:
      mongo:
        image: mongo:4.4
        ports:
          - 27017:27017
        options: >-
          --health-cmd="mongo --eval 'db.runCommand({ ping: 1 })'" 
          --health-interval=10s 
          --health-timeout=5s 
          --health-retries=5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'

      - name: Install dependencies
        run: npm install

      - name: Run lint
        run: npm run lint

      - name: Run tests
        run: npm test

      - name: Build Docker image
        run: docker build -t mern-app .

      - name: Run Docker container for deployment verification
        run: docker run --rm -d -p 3000:3000 --name mern-app-container mern-app

      - name: Wait for service to be ready
        run: |
          until curl -s http://localhost:3000; do
            echo "Waiting for the container to be ready..."
            sleep 5
          done

      - name: Run integration tests with Supertest
        run: npm run test

      - name: Install Railway CLI
        run: npm install -g @railway/cli

      - name: Deploy to Railway
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
        run: railway up --service actiongit1

        ------------0-------------

        
  